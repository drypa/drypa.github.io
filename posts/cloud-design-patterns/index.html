<!DOCTYPE html>
<html lang="ru-ru">
  <head>
    <meta charset="utf-8" />
<title>Cloud Design Patterns</title>


  


  
  <script data-goatcounter="https://drypa.github.io/count"
          async src="//drypa.github.io/count.js"></script>


<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link
  rel="alternate"
  type="application/rss+xml"
  href="https://drypa.github.io/index.xml"
  title="Andrey Krasavin Home Page"
/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Cloud Design Patterns"/>
<meta name="twitter:description" content="Cloud Design Patterns  Прочитана в октябрь 2018г.
 Cache-aside- если есть в кэше, читать из него, если нет, читать из бд и обновлять в кэше, хорошо работает если кэш обновлять через write-through
Cache: read-through, write-through, write-behind
При реализации обратить внимание:
 Lifetime of cached data: выбрать время инвалидации исходя из характера работы с приложением. Кэшировать лучше редко-изменяемые данные Evict cache-вытеснение. Кэш ограничен по размеру и надо выбрать стратегию вытеснения. Возможно она для разных сущностей будет разная."/>



<link rel="stylesheet" href="https://drypa.github.io/fontawesome/css/all.min.css" />

<link
  id="dark-mode-theme"
  rel="stylesheet"
  href="https://drypa.github.io/css/dark.css"
/>

<script>
  var darkTheme = document.getElementById('dark-mode-theme')
  var storedTheme = localStorage.getItem('dark-mode-storage')
  if (storedTheme === 'dark') {
    darkTheme.disabled = false
  } else if (storedTheme === 'light') {
    darkTheme.disabled = true
  }
</script>

<script src="https://drypa.github.io/js/main.bundle.js"></script>
<script src="https://drypa.github.io/js/instantpage.min.js" type="module" defer></script>
<meta name="generator" content="Hugo 0.96.0" />
  </head>
  <body>
    
  




  <header>
    <nav class="navbar">
  <div class="nav">
    
      <a href="https://drypa.github.io/" class="nav-logo">
        <img
          src="https://drypa.github.io/images/icon.png"
          width="50"
          height="50"
          alt="Logo"
        />
      </a>
    

    <ul class="nav-links">
      
        
          <li>
            <a href="/about/" id="About"
              ><em class="fas fa-user fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/tags" id="Tags"
              ><em class="fas fa-tag fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/categories" id="Category"
              ><em class="fas fa-folder-open fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/search" id="Search"
              ><em class="fas fa-search fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/archives" id="Archives"
              ><em class="fas fa-archive fa-lg"></em
            ></a>
          </li>
          
      
    </ul>
  </div>
</nav>

    <div class="intro-header">
      <div class="container">
        <div class="posts-heading">
          
            <h1>
              Cloud Design Patterns
            </h1>
          
          
        </div>
      </div>
    </div>
  </header>
  

    
  <div class="container" role="main">
    <article class="article" class="blog-post">
      
  <h1 id="cloud-design-patterns">Cloud Design Patterns</h1>
<blockquote>
<p>Прочитана в октябрь 2018г.</p>
</blockquote>
<p>Cache-aside- если есть в кэше, читать из него, если нет, читать из бд и обновлять в кэше, хорошо работает если кэш обновлять через write-through</p>
<p>Cache: read-through, write-through, write-behind</p>
<p>При реализации обратить внимание:</p>
<ul>
<li>Lifetime of cached data: выбрать время инвалидации исходя из характера работы с приложением. Кэшировать лучше редко-изменяемые данные</li>
<li>Evict cache-вытеснение. Кэш ограничен по размеру и надо выбрать стратегию вытеснения. Возможно она для разных сущностей будет разная.</li>
<li>Priming the cache: заполнять кэш при старте</li>
<li>Нет гарантии консистентности между кэшем и бд</li>
<li>Local(in memory) кэш хорош, Но если работают несколько инстансов сервиса, у каждого свой кэш, и больше вероятностей что они разойдутся. Нужно чаще инвалидировать</li>
</ul>
<h2 id="circuit-breaker">Circuit breaker</h2>
<p>Circuit breaker- для уменьшения расхода ресурсов при длительных проблемах. Выступает как прокси для операций, подсчитывая неудачные попытки.</p>
<p>Должен обрабатывать все типы ошибок.</p>
<p>Должен логировать все упавшие запросы для цели мониторинга.</p>
<p>Должен самовосстанавливать работу, и может какое-то время отвечать, ошибкой когда сервис уже работает.</p>
<p>Может пинговать упавший сервис.</p>
<p>Можно сделать механизм автоматического закрытия.</p>
<p>Должен обеспечивать конкурентную работу.</p>
<p>Нужно разделять ресурсы( например один шард не доступен, остальные работают).</p>
<p>Можно обрабатывать от клиента информацию о том, когда можно делать ретрай.</p>
<p>Не может защитить от сервиса, который долго отвечает.</p>
<h2 id="compensating-transaction">Compensating transaction</h2>
<p>Compensating transaction-отмена операций для обеспечения eventual consistency.</p>
<p>Проблема с откатом изменений, когда данные, которые надо вернуть в первоначальное состояние изменены уже другим потоком</p>
<p>Сама являясь eventual consistency операцией она может упасть, для этого система в случае падения должна обеспечивать повторную попытку выполнения, и компенсирующая транзакция для этого должна быть идемпотентна.</p>
<h2 id="competing-consumers">Competing consumers</h2>
<p>Competing consumers- несколько коньсьмееров выполняют работу, это даёт горизонтальное масштабирование(например когда нагрузка меняется со временем) и отказоустойчивость.</p>
<p>Решение: очередь, она как буфер уменьшая влияние недоступности и генерирующей запросы стороны и обработчиков. Не требует координации между обработчиками(не понятно как этого добиться).</p>
<p>Не гарантирует порядок обработки</p>
<h2 id="compute-resource-consolidation-pattern">Compute resource consolidation Pattern</h2>
<p>Объединять несколько задач для обработки на одном вычислительном узле. Например объединять &ldquo;по потребляемым ресурсам&rdquo;,или редкие задачи вместе. Для уменьшения цены владения системой. Такие юниты уже масштабировать.</p>
<p>Не объединять задачи с конфликтующими требованиями к ресурсам.</p>
<p>Соблюдать ритм релизов для сервисов на одном computational unit, чтобы деплой одного не сказывался на другом.</p>
<p>Увеличение количества задач на одном unit может расширить поверхность атаки.</p>
<p>Падение одной задачи не должно сказываться на других.</p>
<p>Объединение возможно только после эксплуатации, когда собраны метрики о том, как сервис ведёт себя на пром. нагрузке</p>
<p>Добавляет сложности в код.</p>
<h2 id="cqrs">CQRS</h2>
<p>CQRS- разделять чтение и изменение по разным интерфейсам.</p>
<p>Увеличит производительность,масштабируемость,безопасность, гибкость</p>
<p>Проблемы стандартного crud подхода:</p>
<ul>
<li>Несоответствие по полям dto для чтения и записи</li>
<li>Блокировки на чтение или update conflicts</li>
<li>Сложно настроить доступ- безопасность</li>
</ul>
<p>eventual consistency:</p>
<ul>
<li>Хорошо масштабируется на чтение</li>
<li>Не подходит для простых случаев</li>
<li>Не подходит для реализации всей системы, только частей</li>
<li>Хорошо сочетается с event sourcing</li>
<li>Усложнение за счёт управления событиями для обновления read view</li>
<li>Но может упростить отдельные части(домен чтения)</li>
</ul>
<h2 id="event-sourcing">Event Sourcing</h2>
<p>Вместо того, чтобы хранить только текущее состояние в домене использовать append-only хранилище для записи событий с доменом</p>
<p>Когда применять:</p>
<ul>
<li>Когда нужно фиксировать причину изменения</li>
<li>Когда важно минифицировать коныликтные обновления</li>
<li>Когда надо иметь возможность переиграть события ещё раз</li>
<li>Когда события- это часть домена предметной области</li>
<li>Когда хочется разделить процеззы модификации и задачи по применению изменений</li>
<li>Когда нужно иметь возможность менять формат материализованного представления</li>
<li>Когда допустимо иметь eventual consistency</li>
</ul>
<h2 id="external-configuration-store">External configuration store</h2>
<p>Перенести конфигурацию задеплоенного приложения в единое место для более лёгкого управления конфигурацией и предоставить к этой информации быстрый и понятный api.</p>
<p>Нужно выбрать удобное, гибкое, масштабируемое хранилище для настроек, и выбрать правильную, расширяемую схему хранения</p>
<h2 id="federated-identity-pattern">Federated identity pattern</h2>
<p>-delegate authentication to an external identity provider</p>
<h2 id="gatekeeper">Gatekeeper</h2>
<p>Для защиты приложений используется выделенный хост выступающий брокером между клиентами и приложениями, валидирует и обеззараживает запросы пользователей и далее пробрасывать их в приложения.</p>
<ul>
<li>Внутренние хосты предоставляют доступ только через gatekeeper и не торчат наружу.</li>
<li>Gatekeeper обладает минимумом привилегий</li>
<li>Не выполняет обработку запросов и не имеет доступ к данным.</li>
<li>Использует защищённое соединение с внутренними хостами.</li>
<li>Снижает производительность</li>
<li>Single point of failure</li>
</ul>
<h2 id="endpoont-health-monitoring">Endpoont Health Monitoring</h2>
<p>Предоставить точку доступа, через которую внешние системы могут проверять корректность работы сервиса</p>
<h2 id="index-table">Index table</h2>
<p>Для систем, где нет secondary index можно их эмулировать</p>
<p>Такие таблицы могут быть с денормализованы(с полным дублированием данных в каждом индексе, частично(только часть наиболее часто используемых данных дублируется) или полностью нормализованные.</p>
<h2 id="leader-election">Leader election</h2>
<p>В распределенных системах,когда работают несколько исполнителей задач выбирается лидер чтобы решать конфликты между ними.
Много воркеров может быть из-за применения горизонтального масштабирования или применения паттерна map-reduce.</p>
<p>Обычно подчинённые задачи мониторят лидера с помощью heartbeat или polling и если лидер не доступен запускают механизм выбора нового лидера.</p>
<p>Варианты голосования: например у кого больше processId, или кто успел завладеть глабальным ресурсом(мьютексом)- единая точка отказа, или более сложные маханизмы.</p>
<h2 id="materialized-view">Materialized view</h2>
<p>Формировать предпроектные представления данных, чтобы не нужно было в момент чтения выполнять запрос к бд с фильтрацией и агрегацией.</p>
<p>Нужно определиться когда и как обновлять вью. Принимать во внимание возможность неконсистентности и нагрузки на создание представлений.</p>
<h2 id="pipes-and-filters">Pipes and filters</h2>
<p>Разбить выполнение сложного процесса на серию дискретных действий, которые могут быть переиспользованы в других сценариях.</p>
<p>Позволяет улучшить производительность, масштабируемость.</p>
<p>Добавляет сложности. + Надо обеспечивать идемпотентность каждой операции. Много информации нужно в качестве контекстов выполнения для каждого шага(фильтра)</p>
<h2 id="priority-queue">Priority queue</h2>
<p>Варианты реализации:</p>
<ul>
<li>Reordering сообщений внутри одной очереди</li>
<li>Под каждый приоритет своя очередь</li>
</ul>
<p>Много очередей- партиционирование и лучшее масштабировюание.</p>
<p>На каждый из очередей можно назначать своё количество обработчиков.</p>
<h2 id="queue-based-load-leveling">Queue-based load leveling</h2>
<p>Использовать очередь в качестве буфера между запросом и сервисом. Поможет справиться с большими нагрузками</p>
<p>Не подходит там, где нужна минимальная latency</p>
<h2 id="retry">Retry</h2>
<p>Позволить приложению обрабатывать ожидаемые временные ошибки с помощью повторного выполнения задачи, прозрачно для вызывающего.</p>
<p>Для повышения стабильности.</p>
<p>Выбор этого паттерна должен опираться на требования бизнеса, иногда требуется упасть после первой-же ошибки.</p>
<p>Не стоит делать много попыток с минимальным временем между ними, можно получить DoS</p>
<p>Хорошо применять с circuit breaker.</p>
<p>Операция, которую ретраим должна быть идемпотентной.</p>
<p>Увеличивает время запроса для вызывающего</p>
<h2 id="runtime-reconfiguration">Runtime reconfiguration</h2>
<p>Позволять вносить правки в конфигурацию без переделок и остановки сервиса</p>
<h2 id="scheduler-agent-surervisor">Scheduler agent surervisor</h2>
<p>Если приложение выполняет задачу, которая состоит из нескольких независимых шагов, которые могут, например, обращаться к удаленным сервисам. Могут происходить ошибки. Предлагается, чтобы приложение детектило &ldquo;more permanent faults&rdquo; и должно возвратить систему в консистенцией состояние.</p>
<p>В реализации выступают следующие действующие лица:</p>
<ul>
<li>Scheduler-располагает шаги в нужном порядке. Шаги могут группироваться в pipeline или workflow и он ответственен за то, чтобы шаги выполнялись в нужном порядке. Для каждого шага он поддерживает актуальное состояние. И отслеживает лимиты времени выполнения каждого шага. Если шаг требует вызова удаленного сервиса, то он вызывает соответствующего агента( асинхронно через очередь). Выполняет функцию process manager pattern</li>
<li>Agent-инкапсулирует логику обращения к удаленным сервисам. Включает errer handling, retry, etc.</li>
<li>Supervisor- мониторит состояния всех шагов, наличие таймаутов или ошибок и просит агентов выполнить лечебные(remedial) действия. Не знает какую бизнес функцию выполняет система. Не должен мониторить агентов и scheduler-а на случай их падения, этим должна заниматься инфраструктура.</li>
</ul>
<h2 id="sharding">Sharding</h2>
<p>Разделить хранилище данных на несколько горизонтальных частей для масштабируемости больших объемов данных. Масштабирует:</p>
<ul>
<li>Размер дисков</li>
<li>Вычислительные ресурсы</li>
<li>Полосу пропускания</li>
<li>Географическое расположение данных</li>
</ul>
<p>Логика шардирования должна абстрагировать физическое расположение данных.</p>
<p>Нужно при шардинге учитывать предполагаемые запросы.</p>
<p>Стратегии шардирования:</p>
<ul>
<li>The Lookup- построить словарь для роутинга запроса на нужный шард. Для мультитенант систем ключ- тенант id. Несколько тенант могут обращаться на 1 шард, но данные для одного не должны распределяться на нескольких. Виртуальный шардинг- ключ мапится на виртуальный шард который мапится на меньшее количество физических шардов, позволяет гибко ребалансировать.</li>
<li>The Range- группировать связанные сущности вместе в шарде. Ключ- последовательный. Каждый шард содержит промежуток ключей. Эта стратегия удобна для запросов by using range queries</li>
<li>The Hash- для уменьшения шансов горячих точек используется. Берется хэш от ключа.</li>
</ul>
<p>Нужно разделять часто меняющиеся данные на разные шарды. Шардинг-, чтобы данные были ближе к потребителю.</p>
<p>Некоторым tenant-ам стоит выделять собственные шарды.</p>
<p>Нужно держать шарды сбалансированными по I/O.</p>
<p>Использовать стабильные данные в качестве ключа+ уникальность ключа.</p>
<h2 id="static-content-hosting">Static content hosting</h2>
<p>Уменьшение затрат на хостинг</p>
<p>Перенос контента ближе к пользователю в гео-распределенных cdn.</p>
<h2 id="throttling">Throttling</h2>
<p>Когда кончаются ресурсы на обработку запросов и автоскейлинг не вариант.</p>
<p>Когда значение потребляемых ресурсов достигает порога.</p>
<p>Варианты:</p>
<ul>
<li>Отклонять запросы от одного пользователя чаще чем х времени</li>
<li>Деградация функциональности</li>
<li>Понижение приоритетов при использовании queue based load veleling</li>
</ul>
<p>Если приходится отбрасывать запросы пользователя, ему надо об этом соответствующим кодом ошибки.</p>
<h2 id="valet-key">Valet key</h2>
<p>Клиенту приложения нужно загрузить файл в хранилище, или взять из него. Можно приложению выступать в роли gatekeeper, для хранилища, но тут накладные расходы на трансфер через приложение, поэтому лучше, чтобы клиент ходил напрямую в хранилище. Само хранилище не может управлять аутентификацией и авторизацией.</p>
<p>Надо выдать токен доступа(который хранилище сможет валидировать) к хранилищу, и ограничить публичный доступ</p>
<p>Токен ограничен по времени и может иметь описание доступных скоупов</p>




      
    </article>
    
    
      

    
  </div>

    <footer>
  

<div class="social-icons">
  
    
    
      
      <a href="link%20to%20social%20media" name="name of social media">
        <em class="A icon from https://fontawesome.com/"></em>
      </a>
    
  

  
</div>


  
  <div class="container">
    <p class="credits copyright">
      <a href="https://drypa.github.io/about">Andrey Krasavin</a>
      &nbsp;&copy;
      2022
      
        &nbsp;/&nbsp;
        <a href="https://drypa.github.io/">Andrey Krasavin Home Page</a>
      
      &nbsp;&ndash;&nbsp;
      <em class="fas fa-moon" id="dark-mode-toggle"></em>
    </p>

    <p class="credits theme-by">
       <a href="https://gohugo.io">Hugo</a>&nbsp;
      
      <a href="https://github.com/matsuyoshi30/harbor">Harbor</a>
    </p>
  </div>
</footer>

  </body>
</html>
